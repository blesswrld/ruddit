generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql" // Указываем, что у нас PostgreSQL
  url          = env("DATABASE_URL") // Prisma возьмет URL из .env файла
  relationMode = "prisma"
}

model User {
  id                 String   @id @default(cuid()) // Уникальный ID
  username           String   @unique // Имя пользователя, должно быть уникальным
  email              String   @unique // Email, тоже уникальный
  passwordHash       String   // Здесь будет храниться ЗАХЕШИРОВАННЫЙ пароль
  avatarUrl          String?  // Аватар (необязательно)
  bio                String?  // Описание профиля (необязательно)

  linkTelegram       String?
  linkInstagram      String?
  linkYouTube        String?
  linkTikTok         String?
  linkCustomName     String? // Имя для кастомной ссылки
  linkCustomUrl      String? // URL для кастомной ссылки

  profileMusicUrl    String?
  profileBannerColor String?

  createdAt          DateTime @default(now()) // Дата создания
  updatedAt          DateTime @updatedAt // Дата обновления

  // Связи
  createdCommunities Community[] @relation("CreatedCommunities")
  posts              Post[]
  votes              Vote[]
  comments           Comment[]
  subscriptions      Subscription[]
  notifications      Notification[] @relation("Notifications")
  sentNotifications  Notification[] @relation("SentNotifications")
  
  // Связи для чата
  conversations      Conversation[] @relation("ConversationParticipants")
  sentMessages       Message[]
}

model Community {
  id          String   @id @default(cuid())
  name        String   // Название сообщества
  slug        String   @unique // Слаг должен быть уникальным
  description String?  // Описание, необязательное
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Связь с создателем
  creatorId   String
  creator     User     @relation("CreatedCommunities", fields: [creatorId], references: [id])

  posts Post[]

  subscribers Subscription[]
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorId  String
  author    User     @relation(fields: [authorId], references: [id])

  communityId String
  community   Community @relation(fields: [communityId], references: [id])

  votes Vote[]

  comments Comment[]

  notifications Notification[]

  images Image[]

  videoUrl  String?
}

model Image {
  id     String @id @default(cuid())
  url    String // URL изображения в Yandex Storage
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
}

enum VoteType {
  UP
  DOWN
}

model Vote {
  userId String
  postId String
  type   VoteType

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@id([userId, postId]) // Составной ключ: пара (user, post) уникальна
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  createdAt DateTime @default(now())

  // Связь с автором
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Связь с постом
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Связь для ответов (self-relation)
  replyToId String?
  replyTo   Comment?  @relation("Replies", fields: [replyToId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  replies   Comment[] @relation("Replies")

  notifications Notification[]
}

model Subscription {
  userId      String
  communityId String

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@id([userId, communityId]) // Составной ключ: пара (user, community) уникальна
}

enum NotificationType {
  NEW_REPLY          // Новый ответ на комментарий
  NEW_COMMENT_ON_POST // Новый комментарий к посту
  NEW_POST_IN_SUB    // Новый пост в сообществе, на которое пользоватеель подписан
  POST_UPVOTE        // Кто-то лайкнул пост
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  isRead    Boolean  @default(false) // Прочитано ли уведомление
  type      NotificationType

  // Для кого это уведомление
  recipientId String
  recipient   User     @relation("Notifications", fields: [recipientId], references: [id], onDelete: Cascade)

  // Кто вызвал уведомление
  senderId String
  sender   User     @relation("SentNotifications", fields: [senderId], references: [id], onDelete: Cascade)
  
  // Где это произошло (ссылки)
  postId    String?
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  commentId String?  // Комментарий, на который ответили
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
}

model Conversation {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Участники беседы (многие-ко-многим с User)
  participants  User[]    @relation("ConversationParticipants")

  // Сообщения в этой беседе
  messages      Message[]
}

model Message {
  id             String      @id @default(cuid())
  text           String
  createdAt      DateTime    @default(now())

  // Автор сообщения
  authorId       String
  author         User        @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Беседа, к которой относится сообщение
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}